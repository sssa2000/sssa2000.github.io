---
layout: post
title: "dwm"
date: 2014-05-13 02:34
comments: true
categories: 
---
<!--more-->

DWM的全称是：Desktop Window Manager。它的主要功能是控制桌面绘制的相关内容。
从Vista开始，DWM就成为了windows操作系统中一个重要的组件，到今天的Win8中，DWM变得更加重要，已经是不可关闭的组件了。

---
##桌面渲染方式
在XP以及更古老的windows中，可以把桌面看成是一个单独的buffer，所有的窗口模式的程序都直接在桌面上绘制。窗口应用程序响应WM_PAINT消息，绘制自己的可见区域，绘制结果体现在桌面中。

这样做的好处当然是：计算量最小，且不需要额外的存储空间。理论上来说，如果所有的应用程序都不出什么问题的话，也工作的很好。坏处是，如果某些程序失去响应，那么就会出现类似的效果：
 {% img/images/dwm/1.jpg %}
在Vista出现后，上面的画面几乎很难在看到了，这就是DWM的功劳。Vista以后，每个窗口程序都有自己的一块画布，各自管各自的绘制。DWM 获取当前所有的窗口列表，并管理每个窗口的画布，然后将其组合到最终桌面（composition）。

##DWM提供的功能

 1. 解决窗口无法重绘带来的残影问题。由于每个窗口都绘制到各自的缓冲区上，所以即使某个窗口程序失去响应，缓冲区中依然保存有失去响应前的内容，这样看上去一切安好。
 2. 实现窗口边框的毛玻璃效果。DWM能够访问到所有窗口的缓冲区，也能根据窗口的遮挡关系做一些像素的模糊计算。
{% img/images/dwm/2.jpg %}
 3. 实现了Flip3D窗口变换的效果。这也得益于保存了每个窗口的缓冲区。 
{% img/images/dwm/3.jpg %}
 4. 任务栏窗口实时缩略图。得益于保存了每个窗口的缓冲区。
{% img/images/dwm/4.jpg %}
 
 
##如何控制DWM
在Win7和Vista中，是可以关闭DWM的，方法有：
1、	关闭整个操作系统的AERO Glass Theme。
2、	停用DWM服务
3、	通过在App中调用API：DwmEnableComposition

**在Win8中，没有办法停用DWM**。


----------


##DWM怎样工作
DWM其实也是一个全屏D3D程序。DWM维护有一个全屏大小的Buffer。DWM有两种工作方式：Blt Mode的方式和Flip Mode的方式。

###Blt Mode
Blt Mode是最常见的方式，如果应用程序没有特别指定，都是Blt Mode。
在Blt Mode中每个窗口模式的App都有自己独立的BackBuffer。绘制的过程大致是这样的顺序：

 - D3D runtime会给每个窗口模式的程序维护一个额外的surface（DWM redirection surface）。这个额外的surface是可以和DWM跨进程共享的。
 - App更新绘制App自己的BackBuffer。
 - D3D runtime把app的BackBuffer拷贝到DWM redirection surface中。
 - DWM利用跨进程共享机制将每个进程的DWM redirection surface渲染到屏幕上，在渲染的过程中，DWM会顺带做一些透明、模糊之类的操作。
{% img/images/dwm/5.jpg %}

###Flip Mode
Blt Model中有一步额外的拷贝，并且占用了更多的存储空间。
到了Win7以后， App可以选择使用一种叫“D3DSWAPEFFECT_FLIPEX”的方式创建Device，此时绘制的流程是：

 - App更新绘制App自己的BackBuffer。 
 - D3D runtime直接把App的BackBuffer的handle传给DWM
 - DWM直接把这些BackBuffer渲染到屏幕上。如下图所示：
{% img/images/dwm/6.jpg %}

注意，想要使用Flip Mode Present有以下几个约束

 1. 不能有多个Flip Model的swap chains作用在同一个HWND上
 2. 必须是在Win7或者更高的操作系统
 3. 必须使用IDirect3DDevice9Ex，或者更高的Device。


###从GPUView看Flip Mode
为了更直观的比较，我在我的机器（win8.1 64bit，nvidia GTX260显卡）准备了2个demo

 - demo1，创建device的时候使用的d3d9ex，指定的是D3DSWAPEFFECT_DISCARD。
 - demo2，创建device的时候使用的d3d9ex，指定的是D3DSWAPEFFECT_ FLIPEX。其他逻辑和demo1完全一样。

首先看一下demo1，从GPUView中能看到什么。
{% img/images/dwm/7.jpg %}
每一个垂直同步周期内，DWM先画，demo1后画。

再看demo2，出乎意料：
{% img/images/dwm/8.jpg %}
 
你会发现，demo2在GPUView中体现出了几个奇怪的地方：

 1. 我们的进程中，只有Present token packet没有Present packet。即使是在GPU Hardware Queue中也看不到Present packet，只有DMA packet。那么我猜测在Dx文档中说的“present to DWM”的意思是不是说，由DWM来执行实际的绘制工作，App仅仅是将command buffer的内容给了DWM？
 2. 每一个垂直同步周期，是先让demo2的进程提交数据给GPU，然后再DWM画，然后再让demo2的进程提交数据格GPU。从图形上看好像是demo2的进程提交数据给GPU的过程被DWM的绘制打断了，这从图中的黑色方块能够得到说明，黑色方块代表的含义就是Preemption packet，这表示GPU调度器在运行。
 3. DWM每个垂直同步周期的前期，会发出一个Signal command packet，而我们从Contex CPU Queue中可以看到，CPU端频繁的在等待这个signal command。这导致一帧绘制超过了一个垂直同步周期。
{% img/images/dwm/9.jpg %}

##题外话：Direct3D 9Ex
Direct3D 9Ex曾经被人称为Dx9.0L。我们知道Direct3D9.0c是针对XPDM驱动模型的。当Vista发布以后驱动模型改为了WDDM，为了能够让WDDM的功能尽可能的被Dx9的开发者使用，微软弄了一个Direct3D 9Ex出来。可以认为Direct3D 9Ex是具备WDDM先进生产力的Dx9进化版本，这里挑2个有意思的特性说一下。

###glitch的问题
在某些应用场合，例如播放视频音频，如果出现视频和音频不同步（glitch），那么将会很困扰用户。通常来说不同步的现象经常发生在GPU这里。所以先讲一下理想的Present的情况是什么样的。

理想的Present是：CPU+GPU每更新一次BackBuffer，显示器就刷新一次。假设显示器的刷新率是60Hz，那么理想情况下，CPU+GPU每秒更新60次BackBuffer。

那么，如果CPU+GPU达不到每秒更新BackBuffer 60次，那么带来的后果是，用户从显示器看到的画面在某些时刻是上一帧的画面，在某些时刻是本帧的画面，这样给人的感受是画面卡顿、不均匀的跳动。

在某些场合下，这样的现象是不能接受的。例如：某些程序的逻辑是按照帧来计算的，比如控制一个小球，每帧在世界空间中移动5个单位的距离。假设一切都很完美，此时由于某种原因导致程序突然卡了20ms，那么如果不采取措施的话，绘制到显示器的画面中小球的位置和逻辑世界中的小球的位置永远会有一个偏差。
###如何获知发生了glitch？
有两个方法可以获知。

 - 使用GPUView
 - 使用IDirect3DSwapChain9Ex提供的GetPresentStatistics接口

使用GPUView的方法很简单，看Flip Queue那一栏，如果有出现在某一个垂直同步周期内没有东西，就是发生了Glitch
{% img/images/dwm/10.jpg %}

顺便提一下Flip Queue中方块的含义的详细信息里面有一些有意思的信息
{% img/images/dwm/11.jpg %}

IDirect3DSwapChain9Ex提供的GetPresentStatistics接口能获取Present的统计信息。通过GetPresentStatistics接口获得的Present统计信息具体如下。

```
typedef struct _D3DPRESENTSTATS
{
//表示当前正在被绘制到屏幕上的Present的ID
  UINT PresentCount; 

// 自上一次成功绘制到屏幕后，已经过去了几个VBLANK周期
  UINT PresentRefreshCount;

//调度器上一次调用QueryPerformanceCounter时，已经过去的VBLANK的周期数。（如果每//次VBlank都成功的present的话，SyncRefreshCount应该等于PresentRefreshCount）
  UINT SyncRefreshCount;

//调度器上一次调用QueryPerformanceCounter时，得到的时间
  LARGE_INTEGER SyncQPCTime;

//没用
  LARGE_INTEGER SyncGPUTime;
} D3DPRESENTSTATS;
```

为了使用这个功能，需要在CreateDevice的时候，给参数BehaviorFlags传入D3DCREATE_ENABLE_PRESENTSTATS。

根据前文，简要的说理想情况是，程序的绘制过程能在一个VBlank周期内被绘制到屏幕上。换句话说，假设有一个时间上有序的Present队列：A、B、C、D、E。假设A是在T1时刻被绘制到屏幕上，理想情况下，B应该是在T1之后的1个VBlank周期内被绘制到屏幕上，依次类推。

为了能够判断程序是否发生glitch，可以在程序中记录一个队列，队列中保存：

 - Present ID. 使用IDirect3DSwapChain9Ex::GetLastPresentCount获得。
 - 理想情况下，该Present ID对应的帧，应该是何时被绘制到屏幕上。这个值是计算出来的。通过对队列中第一帧被绘制到屏幕的时间计算。

程序每次执行Present后，通过IDirect3DSwapChain9Ex:: GetPresentStatistics接口获取当前正在被绘制到屏幕上的是哪一个Present的ID。通过这个值和理想情况下值比较，如果不相等那么就证明发生了glitch。

###如何纠正glitch？
前提条件：

 - Win7或者更新的操作系统
 - 创建设备时使用D3DSWAPEFFECT_FLIPEX标志
 - 建议BackBuffer数量不小于3。

通常情况下，在我们调用D3D Device的Present接口后，D3D会等待GPU接收命令队列。如果GPU忙，那么此时D3D Device的Present接口会阻塞住。如果你想让GPU跳过某些帧，在Win7以前是做不到的。

Win7出现后，如果创建的是D3D DeviceEx，那么我们能够在Present的时候指定D3DPRESENT_FORCEIMMEDIATE或者D3DPRESENT_INTERVAL_IMMEDIATE，这能够使得D3D忽略掉上一帧。

例如：依次执行PresentA、PresentB、PresentC，其中PresentA和PresentB都使用D3DPRESENT_INTERVAL_ONE，PresentC使用D3DPRESENT_INTERVAL_FORCEIMMEDIATE，那么D3D接到PresentC后，如果PresentB还没有显示的话，将不会显示PresentB。

所以，如果想忽略掉多帧，那么需要调用多次：
```
g_pd3dDevice->PresentEx(NULL, NULL, NULL, NULL, D3DPRESENT_FORCEIMMEDIATE | D3DPRESENT_DONOTFLIP);
```
